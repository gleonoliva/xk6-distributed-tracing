package client

import (
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"time"
)

const (
	PropagatorW3C    = "w3c"
	HeaderNameW3C    = "traceparent"
	PropagatorB3     = "b3"
	HeaderNameB3     = "b3"
	PropagatorJaeger = "jaeger"
	HeaderNameJaeger = "uber-trace-id"
)

func GenerateHeaderBasedOnPropagator(propagator string, traceID string) (http.Header, error) {

	switch propagator {
	case PropagatorW3C:
		// Docs: https://www.w3.org/TR/trace-context/#version-format
		return http.Header{
			HeaderNameW3C: {fmt.Sprintf("00-%s-%s-01", traceID, RandHexStringRunes(16))},
		}, nil
	case PropagatorB3:
		// Docs: https://github.com/openzipkin/b3-propagation#single-header
		return http.Header{
			HeaderNameB3: {fmt.Sprintf("%s-%s-1", traceID, RandHexStringRunes(8))},
		}, nil
	case PropagatorJaeger:
		// Docs: https://www.jaegertracing.io/docs/1.29/client-libraries/#tracespan-identity
		return http.Header{
			HeaderNameJaeger: {fmt.Sprintf("%s:%s:0:1", traceID, RandHexStringRunes(8))},
		}, nil
	default:
		return nil, fmt.Errorf("unknown propagator: %s", propagator)
	}
}

var hexRunes = []rune("123456789abcdef")

func RandHexStringRunes(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = hexRunes[rand.Intn(len(hexRunes))]
	}
	return string(b)
}

const (
	K6Prefix    = 0756 // Being 075 the ASCII code for 'K' :)
	K6CloudCode = 12   // To ingest and process the related spans in k6 Cloud.
	K6LocalCode = 33   // To not ingest and process the related spans, b/c they are part of a non-cloud run.
	Size        = 16   // Size in bytes of the encoded TraceId
)

// TraceID represents a trace-id format defined to identify k6 spans in this [design doc]
//
// [design doc]: https://docs.google.com/document/d/1AI139s2sssm8geZ31iwEC1DtXFdn2behKpagf5fFnr4/edit#
type TraceID struct {
	// Prefix is the first 2 bytes of the trace-id, and is used to identify the trace as k6
	Prefix int16

	// Code is the third byte of the trace-id and is used to decide whether to process the trace or not, depending on the origin
	Code int8

	// Time is the time at which the trace-id was generated.
	//
	// The time component is used as a source of randomness, and to ensure
	// uniqueness of the trace-id.
	//
	// When encoded, it should be in a format occupying the last 8 bytes of
	// the trace-id, and should ideally be encoded as nanoseconds.
	Time time.Time
}

// IsValid returns true if the TraceID was generated either by a local or cloud run of k6
func (t *TraceID) IsValid() bool {
	return t.Prefix == K6Prefix && (t.Code == K6CloudCode || t.Code == K6LocalCode)
}

// IsValidCloud returns true if the TraceID was generated by a cloud run of k6
func (t *TraceID) IsValidCloud() bool {
	return t.Prefix == K6Prefix && t.Code == K6CloudCode
}

// Encode encodes the TraceID into a hex string.
//
// The trace id is first encoded as a 16 bytes sequence, as follows:
// 1. Up to 2 bytes are encoded as the Prefix
// 2. The third byte is the Code.
// 3. Up to the following 8 bytes are Time.
// 4. The remaining bytes are filled with random bytes.
//
// The resulting 16 bytes sequence is then encoded as a hex string
func Encode(t TraceID, randomReader io.Reader) (string, error) {
	if !t.IsValid() {
		return "", fmt.Errorf("failed to encode traceID: %v", t)
	}

	buf := make([]byte, Size)

	// The `PutVarint` function encode the given value into
	// the provided buffer, and return the number of bytes written. Thus, it
	// allows us to keep track of the number of bytes written, as we go, and
	// to pack the values to use as less space as possible.
	n := binary.PutVarint(buf, int64(t.Prefix))
	n += binary.PutVarint(buf[n:], int64(t.Code))
	n += binary.PutVarint(buf[n:], t.Time.UnixNano())

	// The rest of the space in the 16 bytes buffer, equivalent to the number
	// of available bytes left after writing the prefix, code and timestamp (index n)
	// is filled with random bytes.
	randomness := make([]byte, Size-len(buf[:n]))
	err := binary.Read(randomReader, binary.BigEndian, randomness)
	if err != nil {
		return "", err
	}

	buf = append(buf[:n], randomness[:]...)
	hx := hex.EncodeToString(buf)
	return hx, nil
}
